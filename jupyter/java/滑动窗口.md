该题目是 LeetCode 第 3 题 **“无重复字符的最长子串”**，要求找到一个字符串中不包含重复字符的最长子串的长度。

### 题目描述：
给定一个字符串 

s

，请你找出其中不含有重复字符的 **最长子串** 的长度。

#### 示例：
1. 输入: 

s = "abcabcbb"


   输出: `3`  
   解释: 最长子串是 `"abc"`，长度为 3。

2. 输入: 

s = "bbbbb"


   输出: `1`  
   解释: 最长子串是 `"b"`，长度为 1。

3. 输入: 

s = "pwwkew"


   输出: `3`  
   解释: 最长子串是 `"wke"`，长度为 3。

---

### 解题思路：
该问题可以通过 **滑动窗口** 技巧解决：
1. 使用两个指针 

i

 和 

j

 表示当前窗口的左右边界。
2. 使用一个数组 

index

（大小为 128，对应 ASCII 字符集）记录每个字符上一次出现的位置。
3. 遍历字符串：
   - 如果当前字符已经在窗口中出现过（即 

index[s.charAt(j)] >= i

），则移动左指针 

i

 到重复字符的下一个位置。
   - 更新窗口的长度 

j - i + 1

，并更新结果 

ans

。
   - 更新当前字符的最新位置 

index[s.charAt(j)] = j + 1

。
4. 最后返回结果 

ans

。

---

### 代码解释：
```java
public int lengthOfLongestSubstring(String s) {
    int n = s.length(); // 字符串长度
    int ans = 0; // 记录最长子串长度
    int[] index = new int[128]; // 记录字符上一次出现的位置（ASCII字符集）

    for (int j = 0, i = 0; j < n; j++) { // j 是右指针，i 是左指针
        i = Math.max(index[s.charAt(j)], i); // 更新左指针，确保窗口内无重复字符
        ans = Math.max(ans, j - i + 1); // 更新最长子串长度
        index[s.charAt(j)] = j + 1; // 更新当前字符的最新位置
    }
    return ans; // 返回结果
}
```

---

### 时间复杂度：
- **O(n)**：每个字符最多被访问两次（一次由右指针 

j

，一次由左指针 

i

）。
- **空间复杂度**：**O(1)**，因为 

index

 数组的大小固定为 128。

这是一个经典的滑动窗口问题，适合用来练习字符串处理和双指针技巧。